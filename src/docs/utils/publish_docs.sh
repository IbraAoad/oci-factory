#!/bin/bash -ex

trace_suspend() {
    case "$-" in *x*)
        set +x
        __resume_trace=1
        ;;
    esac 2>/dev/null
}

DOCS_GIT_URL='https://git.launchpad.net/~ubuntu-docker-images/ubuntu-docker-images/+git/templates'

image_name="${1}"
image_doc_filename="${1}_doc_data"
folder_of_the_image_documentation="data"

AVAILABLE_ARCHS="$(yq -r '.releases[].architectures[]' < "${folder_of_the_image_documentation}"/"${image_doc_filename}".yaml | sort | uniq | paste -sd ',')"

# get the documentation templates
docs_dir_git=templates
git clone --depth 1 -b main "${DOCS_GIT_URL}" ${docs_dir_git}
# get the RenderDown tool used to generate the docs
git clone --depth 1 -b master https://github.com/valentinviennot/RenderDown
# install the dependencies for the RenderDown tool  
pip install -U -r ${docs_dir_git}/requirements.txt -r RenderDown/requirements.txt

# We pass lots of credentials around and some of them can't be redacted by
trace_suspend

# move the documentation file generated by the oci-factory to the templates/<image_name> folder 
mkdir -p ${docs_dir_git}/"${image_name}"
mv "${folder_of_the_image_documentation}/${image_doc_filename}.yaml" ${docs_dir_git}/"${image_name}"

### DockerHub

# 1) build the docs
(cd ${docs_dir_git} && make DATADIR="${image_name}" dockerhub-docs)

# 2) login using DockerHub API to get the token to publish the doc
dh_jw_token=$(curl -X POST  https://hub.docker.com/v2/users/login \
                 -H "Content-Type: application/json" \
                 -d '{"username":"'"${DOCKER_HUB_CREDS_USR_DOC}"'","password":"'"${DOCKER_HUB_CREDS_PSW_DOC}"'"}' | jq -r .token)

# 3) build and ship the doc payload
cat >dockerhub-docs.json <<EOF
 {
 "full_description": "$(awk '{printf "%s\\n", $0}' ${docs_dir_git}/docs/docker.io/ubuntu/"${image_doc_filename}".md | sed 's/"/\\"/g')"
 }
EOF


# We need to remove the docker.io/ before the namespace
# because we only need the namespace for the API

DH_NAMESPACE="${DOCKER_HUB_NAMESPACE#docker.io/}"

# ## we could also add "description" to the payload, for the image's
# ## short summary, but that's unlikely to ever change, so no need to 
# ## keep overwriting it on every build.
curl -X PATCH "https://hub.docker.com/v2/repositories/${DH_NAMESPACE}/${image_name}" \
     -H "Authorization: JWT ${dh_jw_token}" \
     -H "Content-Type: application/json" \
     -d @dockerhub-docs.json

### ECR

# 1) build the docs
(cd ${docs_dir_git} && make DATADIR="${image_name}" ecr-docs)

# # 2) build and ship the doc payload
# # ECR accepts architecture data, but it needs to abide by their naming conventions:
# # https://docs.aws.amazon.com/cli/latest/reference/ecr-public/put-repository-catalog-data.html#options
ecr_archs="${AVAILABLE_ARCHS} $(echo "${AVAILABLE_ARCHS}" | sed 's/armhf/arm/g' | tr '[:lower:]' '[:upper:]' | sed 's/AMD64/x86-64/g')"
if [[ "${ecr_archs}" == *"ARM64"* ]]
then
     ecr_archs_mapped="$(echo "$ecr_archs" | jq -R 'split(" ")' | jq '. |= . + ["ARM 64"]')"
else
     ecr_archs_mapped="$(echo "$ecr_archs" | jq -R 'split(" ")')"
fi
cat >ecr-docs.json <<EOF
 {
 "architectures": ["Linux"],
 "operatingSystems": ${ecr_archs_mapped},
 "usageText": "$(awk '{printf "%s\\n", $0}' ${docs_dir_git}/docs/public.ecr.aws/ubuntu/usage/"${image_doc_filename}".md | sed 's/"/\\"/g')",
 "aboutText": "$(awk '{printf "%s\\n", $0}' ${docs_dir_git}/docs/public.ecr.aws/ubuntu/"${image_doc_filename}".md | sed 's/"/\\"/g')"
 }
EOF


AWS_SECRET_ACCESS_KEY=${ECR_CREDS_PSW} AWS_ACCESS_KEY_ID=${ECR_CREDS_USR} \
aws --region us-east-1 ecr-public put-repository-catalog-data \
     --registry-id="${ECR_REGISTRY_ID}" --repository-name "${image_name}" --catalog-data "$(cat ecr-docs.json)"